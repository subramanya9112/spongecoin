listen to that socket
    -> on transaction
    -> on block mined
    -> consensus

    -> on i got a transaction
    -> on i got a new block
    -> on i obey on consensus

client
    -> send status
    -> recieve start
    -> send number of blocks
    -> recieve transaction
    -> send client balance
    -> send client transactions
    -> send blocks range
    -> send a block details

miner
    -> create sidechain
    -> mined coins
    -> mine blocks

block
    block size
    block header
        previous block hash
        merkle root
        timestamp (unix time)
        difficulty target
        nonce
    transaction counter
    transactions

first_target  = 00000000ffff0000000000000000000000000000000000000000000000000000
New Target= Old Target * (T / 2 weeks)
New Target= Old Target * (Time taken for 2016 Blocks in Seconds / 12,09,600 seconds)

consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
consensus.nPowTargetSpacing = 10 * 60;
consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing


int64_t GetBlockValue(int nHeight, int64_t nFees)
{
 int64_t nSubsidy = 50 * COIN;
 int halvings = nHeight / Params().SubsidyHalvingInterval();
 // Force block reward to zero when right shift is undefined.
 if (halvings >= 64)
 return nFees;
 // Subsidy is cut in half every 210,000 blocks which will 
occur approximately every 4 years.
 nSubsidy >>= halvings;
 return nSubsidy + nFees;
}


start the mainchain
time for each block
difficulty target
pub_key

Needed variables
    totalCoins
    difficultyTarget
    adjustAfterBlocks
    timeForEachBlock
    
    subsidy
    subsidyHalvingInterval
    completion on -> calculated on ui

    pub_key
    minimum_fee
    maximum_time
